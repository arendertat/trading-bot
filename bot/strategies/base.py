"""Base strategy interface for all trading strategies"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional

from bot.core.constants import OrderSide, RegimeType

logger = logging.getLogger("trading_bot.strategies")


@dataclass
class FeatureSet:
    """
    Technical indicators and features for strategy evaluation.

    All features calculated by Feature Engine and passed to strategies.
    """
    # Price action indicators
    rsi_5m: float
    ema20_5m: float
    ema50_5m: float
    ema20_1h: float
    ema50_1h: float
    atr_5m: float

    # Bollinger Bands
    bb_upper_5m: float
    bb_lower_5m: float
    bb_middle_5m: float

    # Breakout features
    high_20_bars: float
    low_20_bars: float

    # Volume features
    volume_z_5m: float

    # Additional metrics
    adx_5m: Optional[float] = None
    atr_z_5m: Optional[float] = None
    bb_width_5m: Optional[float] = None


@dataclass
class StrategySignal:
    """
    Trade signal generated by strategy.

    Contains all information needed for position sizing and order execution.
    """
    entry: bool  # True if entry conditions met
    side: Optional[OrderSide]  # LONG or SHORT
    stop_pct: float  # Stop loss distance as percentage
    target_r: float  # Take profit in R multiples
    entry_price: float  # Suggested entry price
    stop_price: float  # Stop loss price
    tp_price: float  # Take profit price
    trail_enabled: bool  # Enable trailing stop
    trail_after_r: float  # Enable trailing after this R profit
    atr_trail_mult: float  # Trailing distance multiplier
    reason: str  # Human-readable entry reason
    symbol: str  # Trading symbol
    timestamp: int = 0  # Unix timestamp of signal generation


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.

    Each strategy must implement:
    - entry_conditions(): Check if entry conditions met
    - calculate_stop_loss(): Calculate stop price
    - calculate_take_profit(): Calculate TP price
    - leverage_mapping(): Return leverage for given regime (optional override)

    The base class provides:
    - generate_signal(): Orchestrates signal generation flow
    - Default leverage mapping per regime
    """

    def __init__(self, config: dict):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy-specific configuration dict
        """
        self.config = config
        self.enabled = config.get("enabled", True)
        self.name = self.__class__.__name__
        logger.info(f"Strategy '{self.name}' initialized (enabled={self.enabled})")

    @abstractmethod
    def entry_conditions(
        self,
        features: FeatureSet,
        regime_result,  # RegimeResult from regime module
        symbol: str,
        current_price: float
    ) -> tuple[bool, Optional[OrderSide], str]:
        """
        Check if entry conditions are met.

        Args:
            features: Calculated technical indicators
            regime_result: Current regime detection result
            symbol: Trading symbol
            current_price: Current market price

        Returns:
            (conditions_met, side, reason)
            side: LONG or SHORT if conditions met, else None
            reason: Human-readable explanation
        """
        pass

    @abstractmethod
    def calculate_stop_loss(
        self,
        entry_price: float,
        side: OrderSide,
        atr: float
    ) -> float:
        """
        Calculate stop loss price.

        Args:
            entry_price: Entry fill price
            side: LONG or SHORT
            atr: Average True Range (14)

        Returns:
            Stop loss price
        """
        pass

    @abstractmethod
    def calculate_take_profit(
        self,
        entry_price: float,
        stop_price: float,
        side: OrderSide
    ) -> float:
        """
        Calculate take profit price.

        Args:
            entry_price: Entry fill price
            stop_price: Stop loss price
            side: LONG or SHORT

        Returns:
            Take profit price
        """
        pass

    def leverage_mapping(self, regime: RegimeType) -> float:
        """
        Map regime to leverage.

        Default mapping (can be overridden):
        - TREND: 2.0x
        - RANGE: 1.5x
        - HIGH_VOL: 1.0x
        - CHOP_NO_TRADE: 1.0x

        Args:
            regime: Current market regime

        Returns:
            Leverage multiplier (1.0 - 2.0)
        """
        mapping = {
            RegimeType.TREND: 2.0,
            RegimeType.RANGE: 1.5,
            RegimeType.HIGH_VOL: 1.0,
            RegimeType.CHOP_NO_TRADE: 1.0
        }
        return mapping.get(regime, 1.0)

    def generate_signal(
        self,
        features: FeatureSet,
        regime_result,  # RegimeResult from regime module
        symbol: str,
        current_price: float,
        timestamp: int = 0
    ) -> Optional[StrategySignal]:
        """
        Generate complete trade signal.

        Orchestrates the signal generation flow:
        1. Check if strategy enabled
        2. Check entry conditions
        3. Calculate stop loss
        4. Calculate take profit
        5. Calculate metrics (stop_pct, target_r)
        6. Populate trailing config

        Args:
            features: Calculated technical indicators
            regime_result: Current regime detection result
            symbol: Trading symbol
            current_price: Current market price
            timestamp: Unix timestamp of signal generation

        Returns:
            StrategySignal if conditions met, else None
        """
        if not self.enabled:
            logger.debug(f"{self.name}: Strategy disabled, skipping")
            return None

        # Check entry conditions
        entry, side, reason = self.entry_conditions(
            features, regime_result, symbol, current_price
        )

        if not entry or side is None:
            return None

        # Calculate stop/TP
        stop_price = self.calculate_stop_loss(current_price, side, features.atr_5m)
        tp_price = self.calculate_take_profit(current_price, stop_price, side)

        # Calculate stop distance percentage
        if side == OrderSide.LONG:
            stop_pct = (current_price - stop_price) / current_price
        else:
            stop_pct = (stop_price - current_price) / current_price

        # Target R calculation
        risk_distance = abs(current_price - stop_price)
        target_distance = abs(tp_price - current_price)
        target_r = target_distance / risk_distance if risk_distance > 0 else 1.0

        # Trailing config
        trail_after_r = self.config.get("trail_after_r", 0)
        trail_enabled = trail_after_r > 0
        atr_trail_mult = self.config.get("atr_trail_mult", 2.0)

        logger.info(
            f"{self.name} signal for {symbol}: {side.value} @ {current_price:.2f}, "
            f"stop={stop_price:.2f}, tp={tp_price:.2f}, R={target_r:.2f}"
        )

        return StrategySignal(
            entry=True,
            side=side,
            stop_pct=stop_pct,
            target_r=target_r,
            entry_price=current_price,
            stop_price=stop_price,
            tp_price=tp_price,
            trail_enabled=trail_enabled,
            trail_after_r=trail_after_r,
            atr_trail_mult=atr_trail_mult,
            reason=reason,
            symbol=symbol,
            timestamp=timestamp
        )
