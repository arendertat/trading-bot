"""Base strategy interface for all trading strategies"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional

from bot.core.constants import OrderSide, RegimeType

logger = logging.getLogger("trading_bot.strategies")


@dataclass
class FeatureSet:
    """
    Technical indicators and features for strategy evaluation.

    All features calculated by Feature Engine and passed to strategies.
    """
    # Price action indicators
    rsi_5m: float
    ema20_5m: float
    ema50_5m: float
    ema20_1h: float
    ema50_1h: float
    atr_5m: float

    # Bollinger Bands
    bb_upper_5m: float
    bb_lower_5m: float
    bb_middle_5m: float

    # Breakout features
    high_20_bars: float
    low_20_bars: float

    # Volume features
    volume_z_5m: float

    # Additional metrics
    adx_5m: Optional[float] = None
    atr_z_5m: Optional[float] = None
    bb_width_5m: Optional[float] = None

    # 4h timeframe (Multi-TF confirmation — Özellik 6)
    ema20_4h: Optional[float] = None
    ema50_4h: Optional[float] = None

    # Order book imbalance (Özellik 12)
    # bid_volume / ask_volume — >1 bullish pressure, <1 bearish pressure
    book_imbalance_ratio: Optional[float] = None

    # ATR values by lookback for dynamic stops
    atr_by_lookback: Optional[dict[int, float]] = None


@dataclass
class StrategySignal:
    """
    Trade signal generated by strategy.

    Contains all information needed for position sizing and order execution.
    """
    entry: bool  # True if entry conditions met
    side: Optional[OrderSide]  # LONG or SHORT
    stop_pct: float  # Stop loss distance as percentage
    target_r: float  # Take profit in R multiples
    entry_price: float  # Suggested entry price
    stop_price: float  # Stop loss price
    tp_price: float  # Take profit price
    trail_enabled: bool  # Enable trailing stop
    trail_after_r: float  # Enable trailing after this R profit
    atr_trail_mult: float  # Trailing distance multiplier
    reason: str  # Human-readable entry reason
    symbol: str  # Trading symbol
    timestamp: int = 0  # Unix timestamp of signal generation


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.

    Each strategy must implement:
    - entry_conditions(): Check if entry conditions met
    - compatible_regimes: class attribute listing compatible RegimeTypes

    The base class provides:
    - calculate_stop_loss(): Fixed-pct stop (reads "stop_pct" from config)
    - calculate_take_profit(): Fixed R-multiple TP (reads "target_r_multiple" from config)
    - generate_signal(): Orchestrates signal generation flow
    - Default leverage mapping per regime

    Subclasses may override calculate_stop_loss / calculate_take_profit when
    they need non-standard logic (e.g. TrendBreakout uses 100R TP).
    """

    # Bulgu 8: Subclasses must declare which regimes they support.
    compatible_regimes: list = []

    def __init__(self, config: dict):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy-specific configuration dict
        """
        self.config = config
        self.enabled = config.get("enabled", True)
        self.name = self.__class__.__name__
        logger.info(f"Strategy '{self.name}' initialized (enabled={self.enabled})")

    @abstractmethod
    def entry_conditions(
        self,
        features: FeatureSet,
        regime_result,  # RegimeResult from regime module
        symbol: str,
        current_price: float
    ) -> tuple[bool, Optional[OrderSide], str]:
        """
        Check if entry conditions are met.

        Args:
            features: Calculated technical indicators
            regime_result: Current regime detection result
            symbol: Trading symbol
            current_price: Current market price

        Returns:
            (conditions_met, side, reason)
            side: LONG or SHORT if conditions met, else None
            reason: Human-readable explanation
        """
        pass

    def calculate_stop_loss(
        self,
        entry_price: float,
        side: OrderSide,
        atr: float,
        regime_result,
    ) -> float:
        """
        Calculate stop loss price.

        If dynamic_stop_enabled=True in config, uses ATR-based distance:
            stop_distance = ATR(lookback) * stop_atr_multiplier
        Otherwise falls back to fixed percentage stop_pct.

        ATR-based stop adapts to volatility: tight in low-vol, wider in high-vol.
        """
        if self.config.get("dynamic_stop_enabled", False) and atr and atr > 0:
            multiplier = self.config.get("stop_atr_multiplier", 1.5)
            multipliers = self.config.get("stop_atr_multiplier_by_regime")
            if multipliers and regime_result is not None:
                regime_name = regime_result.regime.value
                if regime_name == "TREND":
                    multiplier = multipliers.get("trend", multiplier)
                elif regime_name == "RANGE":
                    multiplier = multipliers.get("range", multiplier)
                elif regime_name == "HIGH_VOL":
                    multiplier = multipliers.get("high_vol", multiplier)
            stop_distance = atr * multiplier
            min_stop_pct = self.config.get("min_stop_pct", 0.0) or 0.0
            min_stop_usd = self.config.get("min_stop_usd", 0.0) or 0.0
            min_distance = 0.0
            if min_stop_pct > 0:
                min_distance = max(min_distance, entry_price * min_stop_pct)
            if min_stop_usd > 0:
                min_distance = max(min_distance, min_stop_usd)
            if min_distance > 0:
                stop_distance = max(stop_distance, min_distance)
            if side == OrderSide.LONG:
                return entry_price - stop_distance
            return entry_price + stop_distance

        # Fallback: fixed percentage
        stop_pct = self.config.get("stop_pct", 0.01)
        if side == OrderSide.LONG:
            return entry_price * (1 - stop_pct)
        return entry_price * (1 + stop_pct)

    def calculate_take_profit(
        self,
        entry_price: float,
        stop_price: float,
        side: OrderSide
    ) -> float:
        """
        Bulgu 6: Default R-multiple take profit.

        Reads "target_r_multiple" from config (default 2.0).
        Subclasses may override for trailing-only exits (e.g. 100R sentinel).
        """
        target_r = self.config.get("target_r_multiple", 2.0)
        risk_distance = abs(entry_price - stop_price)
        target_distance = risk_distance * target_r
        if side == OrderSide.LONG:
            return entry_price + target_distance
        return entry_price - target_distance

    def leverage_mapping(self, regime: RegimeType) -> float:
        """
        Map regime to leverage.

        Default mapping (can be overridden):
        - TREND: 2.0x
        - RANGE: 1.5x
        - HIGH_VOL: 1.0x
        - CHOP_NO_TRADE: 1.0x

        Args:
            regime: Current market regime

        Returns:
            Leverage multiplier (1.0 - 2.0)
        """
        mapping = {
            RegimeType.TREND: 2.0,
            RegimeType.RANGE: 1.5,
            RegimeType.HIGH_VOL: 1.0,
            RegimeType.CHOP_NO_TRADE: 1.0
        }
        return mapping.get(regime, 1.0)

    def generate_signal(
        self,
        features: FeatureSet,
        regime_result,  # RegimeResult from regime module
        symbol: str,
        current_price: float,
        timestamp: int = 0
    ) -> Optional[StrategySignal]:
        """
        Generate complete trade signal.

        Orchestrates the signal generation flow:
        1. Check if strategy enabled
        2. Check entry conditions
        3. Calculate stop loss
        4. Calculate take profit
        5. Calculate metrics (stop_pct, target_r)
        6. Populate trailing config

        Args:
            features: Calculated technical indicators
            regime_result: Current regime detection result
            symbol: Trading symbol
            current_price: Current market price
            timestamp: Unix timestamp of signal generation

        Returns:
            StrategySignal if conditions met, else None
        """
        if not self.enabled:
            logger.debug(f"{self.name}: Strategy disabled, skipping")
            return None

        # Check entry conditions
        entry, side, reason = self.entry_conditions(
            features, regime_result, symbol, current_price
        )

        if not entry or side is None:
            return None

        # Calculate stop/TP
        atr_value = features.atr_5m
        atr_lookback = self.config.get("stop_atr_lookback")
        if atr_lookback and features.atr_by_lookback:
            atr_value = features.atr_by_lookback.get(atr_lookback, atr_value)
        stop_price = self.calculate_stop_loss(current_price, side, atr_value, regime_result)
        tp_price = self.calculate_take_profit(current_price, stop_price, side)

        # Calculate stop distance percentage
        if side == OrderSide.LONG:
            stop_pct = (current_price - stop_price) / current_price
        else:
            stop_pct = (stop_price - current_price) / current_price

        # Target R calculation
        risk_distance = abs(current_price - stop_price)
        target_distance = abs(tp_price - current_price)
        target_r = target_distance / risk_distance if risk_distance > 0 else 1.0

        # Trailing config
        trail_after_r = self.config.get("trail_after_r", 0)
        trail_enabled = trail_after_r > 0
        atr_trail_mult = self.config.get("atr_trail_mult", 2.0)

        logger.info(
            f"{self.name} signal for {symbol}: {side.value} @ {current_price:.2f}, "
            f"stop={stop_price:.2f}, tp={tp_price:.2f}, R={target_r:.2f}"
        )

        return StrategySignal(
            entry=True,
            side=side,
            stop_pct=stop_pct,
            target_r=target_r,
            entry_price=current_price,
            stop_price=stop_price,
            tp_price=tp_price,
            trail_enabled=trail_enabled,
            trail_after_r=trail_after_r,
            atr_trail_mult=atr_trail_mult,
            reason=reason,
            symbol=symbol,
            timestamp=timestamp
        )
